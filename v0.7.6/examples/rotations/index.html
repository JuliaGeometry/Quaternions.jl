<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Rotations with quaternions · Quaternions.jl</title><meta name="title" content="Rotations with quaternions · Quaternions.jl"/><meta property="og:title" content="Rotations with quaternions · Quaternions.jl"/><meta property="twitter:title" content="Rotations with quaternions · Quaternions.jl"/><meta name="description" content="Documentation for Quaternions.jl."/><meta property="og:description" content="Documentation for Quaternions.jl."/><meta property="twitter:description" content="Documentation for Quaternions.jl."/><meta property="og:url" content="https://JuliaGeometry.github.io/Quaternions.jl/examples/rotations/"/><meta property="twitter:url" content="https://JuliaGeometry.github.io/Quaternions.jl/examples/rotations/"/><link rel="canonical" href="https://JuliaGeometry.github.io/Quaternions.jl/examples/rotations/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Quaternions.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Quaternions.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../api/">APIs</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../basics/">Basics</a></li><li><a class="tocitem" href="../type_parameter/">The type parameter <code>T</code> in <code>Quaternion{T}</code></a></li><li class="is-active"><a class="tocitem" href>Rotations with quaternions</a><ul class="internal"><li><a class="tocitem" href="#Basics"><span>Basics</span></a></li><li><a class="tocitem" href="#Rotation-around-a-vector"><span>Rotation around a vector</span></a></li><li><a class="tocitem" href="#Rotate-a-vector-with-a-quaternion"><span>Rotate a vector with a quaternion</span></a></li><li><a class="tocitem" href="#Convert-a-quaternion-to-a-rotation-matrix"><span>Convert a quaternion to a rotation matrix</span></a></li><li><a class="tocitem" href="#Convert-a-rotation-matrix-to-a-quaternion"><span>Convert a rotation matrix to a quaternion</span></a></li><li><a class="tocitem" href="#Interpolate-two-rotations-(slerp)"><span>Interpolate two rotations (slerp)</span></a></li></ul></li><li><a class="tocitem" href="../dual_quaternions/">Dual quaternions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Rotations with quaternions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Rotations with quaternions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/Quaternions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/Quaternions.jl/blob/main/docs/src/examples/rotations.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Rotations-with-quaternions"><a class="docs-heading-anchor" href="#Rotations-with-quaternions">Rotations with quaternions</a><a id="Rotations-with-quaternions-1"></a><a class="docs-heading-anchor-permalink" href="#Rotations-with-quaternions" title="Permalink"></a></h1><p>One of the most useful application of quaternions is representation of 3D-rotations. See also <a href="https://juliageometry.github.io/Rotations.jl/stable/3d_quaternion/">Rotations.jl documentation</a></p><pre><code class="language-julia hljs">using Quaternions
using LinearAlgebra</code></pre><h2 id="Basics"><a class="docs-heading-anchor" href="#Basics">Basics</a><a id="Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Basics" title="Permalink"></a></h2><p>A 3D rotation can be represented by a <a href="https://en.wikipedia.org/wiki/Versor">unit quaternion (versor)</a>. For example, a 90° rotation around the <span>$y$</span>-axis is <span>$q = \frac{1}{\sqrt{2}} + 0i + \frac{1}{\sqrt{2}} j + 0k$</span>. Rotations with quaternions have the following properties:</p><ul><li>A unit quaternion (4 real numbers) is more efficient for representing a rotation than a rotation matrix (9 real numbers).<ul><li>This results in higher computational performance in terms of time, memory usage, and accuracy.</li></ul></li><li>The negative of a unit quaternion represents the same rotation.</li><li>The conjugate of a unit quaternion represents the inverse rotation.<ul><li>The quaternion has unit length, so conjugate and multiplicative inverse is the same.</li></ul></li><li>The set of unit quaternion <span>$\left\{w + ix + jy + kz \in \mathbb{H} \ | \ x, y, z \in \mathbb{R} \right\} = U(1,\mathbb{H}) \simeq S^3$</span> forms a group, and the group is homomorphic to the following groups.<ul><li><span>$SU(2) = \{R \in \mathcal{M}(2,\mathbb{C}) \ | \ R R^{*} = I\}$</span> is isomorphic to <span>$U(1,\mathbb{H})$</span>.</li><li><span>$SO(3) = \{R \in \mathcal{M}(3,\mathbb{R}) \ | \ R R^\top = I\}$</span> is homomorphic to <span>$U(1,\mathbb{H})$</span>, and the mapping <span>$U(1,\mathbb{H}) \to SO(3)$</span> is double covering.</li></ul></li></ul><h2 id="Rotation-around-a-vector"><a class="docs-heading-anchor" href="#Rotation-around-a-vector">Rotation around a vector</a><a id="Rotation-around-a-vector-1"></a><a class="docs-heading-anchor-permalink" href="#Rotation-around-a-vector" title="Permalink"></a></h2><p>A <span>$\theta$</span> rotation around a unit vector <span>$v = (v_x, v_y, v_z)$</span> can be obtained as</p><p class="math-container">\[q = \cos(\theta/2) + \sin(\theta/2)(iv_x + jv_y + kv_z).\]</p><pre><code class="language-julia hljs">function quat_from_axisangle(axis::AbstractVector, theta::Real)
    if length(axis) != 3
        error(&quot;Must be a 3-vector&quot;)
    end
    s, c = sincos(theta / 2)
    axis = normalize(axis)
    return Quaternion(c, s*axis[1], s*axis[2], s*axis[3])
end</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; q1 = quat_from_axisangle([0,1,0], deg2rad(90))  # 90° rotation around y-axis</code><code class="nohighlight hljs ansi" style="display:block;">QuaternionF64(0.7071067811865476, 0.0, 0.7071067811865475, 0.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; q2 = quat_from_axisangle([1,1,1], deg2rad(120))</code><code class="nohighlight hljs ansi" style="display:block;">QuaternionF64(0.5000000000000001, 0.5, 0.5, 0.5)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; q3 = -q2  # additive inverse quaternion represents the same rotation</code><code class="nohighlight hljs ansi" style="display:block;">QuaternionF64(-0.5000000000000001, -0.5, -0.5, -0.5)</code></pre><h2 id="Rotate-a-vector-with-a-quaternion"><a class="docs-heading-anchor" href="#Rotate-a-vector-with-a-quaternion">Rotate a vector with a quaternion</a><a id="Rotate-a-vector-with-a-quaternion-1"></a><a class="docs-heading-anchor-permalink" href="#Rotate-a-vector-with-a-quaternion" title="Permalink"></a></h2><p>A vector <span>$u = (u_x, u_y, u_z)$</span> can be rotated by a unit quaternion <span>$q$</span>. The rotated vector <span>$v = (v_x, v_y, v_z)$</span> can be obtained as</p><p class="math-container">\[\begin{aligned}
q_u &amp;= iu_x + ju_y + ku_z \\
q_v &amp;= q q_u \bar{q} = 0 + iv_x + jv_y + kv_z \\
v &amp;= (v_x, v_y, v_z).
\end{aligned}\]</p><pre><code class="language-julia hljs">function rotate_vector(q::Quaternion, u::AbstractVector)
    if length(u) != 3
        error(&quot;Must be a 3-vector&quot;)
    end
    q_u = Quaternion(0, u[1], u[2], u[3])
    q_v = q*q_u*conj(q)
    return [imag_part(q_v)...]
end</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; rotate_vector(q1, [1,2,3])</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  3.0
  2.0
 -0.9999999999999993</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; rotate_vector(q2, [1,2,3])</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 3.0
 1.0
 2.0000000000000004</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; rotate_vector(q3, [1,2,3])  # Same as q2</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 3.0
 1.0
 2.0000000000000004</code></pre><h2 id="Convert-a-quaternion-to-a-rotation-matrix"><a class="docs-heading-anchor" href="#Convert-a-quaternion-to-a-rotation-matrix">Convert a quaternion to a rotation matrix</a><a id="Convert-a-quaternion-to-a-rotation-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Convert-a-quaternion-to-a-rotation-matrix" title="Permalink"></a></h2><p>A unit quaternion can be converted to a rotation matrix.</p><pre><code class="language-julia hljs">function rotmatrix_from_quat(q::Quaternion)
    sx, sy, sz = 2q.s * q.v1, 2q.s * q.v2, 2q.s * q.v3
    xx, xy, xz = 2q.v1^2, 2q.v1 * q.v2, 2q.v1 * q.v3
    yy, yz, zz = 2q.v2^2, 2q.v2 * q.v3, 2q.v3^2
    r = [1 - (yy + zz)     xy - sz     xz + sy;
            xy + sz   1 - (xx + zz)    yz - sx;
            xz - sy      yz + sx  1 - (xx + yy)]
    return r
end</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; m1 = rotmatrix_from_quat(q1)</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Float64}:
  2.22045e-16  0.0  1.0
  0.0          1.0  0.0
 -1.0          0.0  2.22045e-16</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m2 = rotmatrix_from_quat(q2)</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Float64}:
  0.0          -1.11022e-16   1.0
  1.0           0.0          -1.11022e-16
 -1.11022e-16   1.0           0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m3 = rotmatrix_from_quat(q3)  # Same as q2</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Float64}:
  0.0          -1.11022e-16   1.0
  1.0           0.0          -1.11022e-16
 -1.11022e-16   1.0           0.0</code></pre><p>This function does not return <a href="https://juliaarrays.github.io/StaticArrays.jl/dev/pages/api/#StaticArraysCore.StaticArray"><code>StaticMatrix</code></a>, so the implementation is not much effective. If you need more performance, please consider using <a href="https://github.com/JuliaGeometry/Rotations.jl">Rotations.jl</a>.</p><h2 id="Convert-a-rotation-matrix-to-a-quaternion"><a class="docs-heading-anchor" href="#Convert-a-rotation-matrix-to-a-quaternion">Convert a rotation matrix to a quaternion</a><a id="Convert-a-rotation-matrix-to-a-quaternion-1"></a><a class="docs-heading-anchor-permalink" href="#Convert-a-rotation-matrix-to-a-quaternion" title="Permalink"></a></h2><p>A rotation matrix can be converted to a unit quaternion. The following implementation is based on <a href="https://arxiv.org/pdf/math/0701759.pdf">https://arxiv.org/pdf/math/0701759.pdf</a>. Note that the following mapping <span>$SO(3) \to U(1,\mathbb{H})$</span> is not surjective.</p><pre><code class="language-julia hljs">function quat_from_rotmatrix(dcm::AbstractMatrix{T}) where {T&lt;:Real}
    a2 = 1 + dcm[1,1] + dcm[2,2] + dcm[3,3]
    a = sqrt(a2)/2
    b,c,d = (dcm[3,2]-dcm[2,3])/4a, (dcm[1,3]-dcm[3,1])/4a, (dcm[2,1]-dcm[1,2])/4a
    return Quaternion(a,b,c,d)
end</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; quat_from_rotmatrix(m1)</code><code class="nohighlight hljs ansi" style="display:block;">QuaternionF64(0.7071067811865476, 0.0, 0.7071067811865475, 0.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; quat_from_rotmatrix(m2)</code><code class="nohighlight hljs ansi" style="display:block;">QuaternionF64(0.5, 0.5, 0.5, 0.5)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; quat_from_rotmatrix(m3)</code><code class="nohighlight hljs ansi" style="display:block;">QuaternionF64(0.5, 0.5, 0.5, 0.5)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; quat_from_rotmatrix(m1) ≈ q1</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; quat_from_rotmatrix(m2) ≈ q2</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; quat_from_rotmatrix(m3) ≈ q3  # q2 == -q3</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><h2 id="Interpolate-two-rotations-(slerp)"><a class="docs-heading-anchor" href="#Interpolate-two-rotations-(slerp)">Interpolate two rotations (slerp)</a><a id="Interpolate-two-rotations-(slerp)-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolate-two-rotations-(slerp)" title="Permalink"></a></h2><p>Slerp (spherical linear interpolation) is a method to interpolate between two unit quaternions. This function <a href="../../api/#Quaternions.slerp"><code>slerp</code></a> equates antipodal points, and interpolates the shortest path. Therefore, the output <code>slerp(q1, q2, 1)</code> may be different from <code>q2</code>. (<code>slerp(q1, q2, 0)</code> is always equal to <code>q1</code>.)</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; slerp(q1, q2, 0) ≈ q1</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; slerp(q1, q2, 1) ≈ q2</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; slerp(q1, q3, 1) ≈ q3</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; slerp(q1, q3, 1) ≈ -q3</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; r = slerp(q1, q2, 1/2)</code><code class="nohighlight hljs ansi" style="display:block;">QuaternionF64(0.6532814824381884, 0.2705980500730985, 0.6532814824381883, 0.2705980500730985)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; abs(q1-r) ≈ abs(q2-r)  # Same distance</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; abs(r)  # Interpolates on the unit sphere S³</code><code class="nohighlight hljs ansi" style="display:block;">1.0</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../type_parameter/">« The type parameter <code>T</code> in <code>Quaternion{T}</code></a><a class="docs-footer-nextpage" href="../dual_quaternions/">Dual quaternions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 5 February 2024 04:10">Monday 5 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
